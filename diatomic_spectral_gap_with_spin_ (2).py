# -*- coding: utf-8 -*-
"""Diatomic_Spectral_Gap_with_Spin_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r26WtIrPYQRJy3Voi4Gg6BblQlTHOTyG
"""

pip install pennylane

import pennylane as qml
import pennylane.numpy as np

"""Define the Molecule, I have H2 here as an example"""

symbols = ["H", "H"]
coordinates = np.array([0.0, 0.0, -0.6614, 0.0, 0.0, 0.6614])      # based on the bond length in atomic units (you have to look it up)
electrons = 2         # number of active electrons

"""Define the number of qubits and the Hamiltonian"""

H, qubits = qml.qchem.molecular_hamiltonian(symbols, coordinates)
print("Number of qubits = ", qubits)
print(H)

"""*   Introducing some spin into this bad boy
*   S2 is the total spin operator squared
"""

S2 = qml.qchem.spin2(electrons, qubits)

"""*   Now we generate the Hartree-Fock state for a given molecular system
*   This is where I was thinking of using MP2 (see file in drive)
*   MP2 is more accurate than HF
*   But it is more intensive so might not work for bigger molecules but might be okay with GPUs
"""

hf = qml.qchem.hf_state(electrons, qubits)

"""we use the excitations() function to generate all single and double excitations of the Hartree-Fock state

singles and doubles contain the qubit indices involved in the single and double excitations

technically could include triples but I think it takes up more computing power than it is work and also we would have to write our own code whereas single and double are built in
"""

singles, doubles = qml.qchem.excitations(electrons, qubits, delta_sz=0)

def circuit(params, wires):
    qml.AllSinglesDoubles(params, wires, hf, singles, doubles)

"""Using a quantum device"""

dev = qml.device("lightning.qubit", wires=qubits)

"""Now we introduce a cost function"""

@qml.qnode(dev, interface="autograd")
def cost_fn(params):
    circuit(params, wires=range(qubits))
    return qml.expval(H)

"""Finding the expectation value of the spin"""

@qml.qnode(dev, interface="autograd")
def S2_exp_value(params):
    circuit(params, wires=range(qubits))
    return qml.expval(S2)

"""Compute total spin"""

def total_spin(params):
    return -0.5 + np.sqrt(1 / 4 + S2_exp_value(params))

"""Minimise the cost function to find the ground state"""

opt = qml.GradientDescentOptimizer(stepsize=0.4)
np.random.seed(0)  # for reproducibility
theta = np.random.normal(0, np.pi, len(singles) + len(doubles), requires_grad=True)
print(theta)

"""Now I'm looping the optimisation aiming to reach a convergence tolerance of  1e-06 for the value of the cost function"""

max_iterations = 100
conv_tol = 1e-06

for n in range(max_iterations):

    theta, prev_energy = opt.step_and_cost(cost_fn, theta)

    ground_energy = cost_fn(theta)
    spin = total_spin(theta)

    conv = np.abs(ground_energy - prev_energy)
    if n % 4 == 0:
        print(f"Step = {n}, Energy = {ground_energy:.8f} Ha, S = {spin:.4f}")

    if conv <= conv_tol:
        break

print("\n" f"Final value of the ground-state energy = {ground_energy:.8f} Ha")
print("\n" f"Optimal value of the circuit parameters = {theta}")

"""# Finding the lowest-lying excited state with  S = 1"""

singles, doubles = qml.qchem.excitations(electrons, qubits, delta_sz=1)

"""Now we want to build our circuit.

We need to apply the corresponding excitation operations.
i.e. singles with singles, doubles with doubles

Again this starts with a HF state, whereas MP2 is more accurate
"""

def circuit(params, wires):
    qml.AllSinglesDoubles(params, wires, np.flip(hf), singles, doubles)

"""Defining cost function and spin expectation value"""

@qml.qnode(dev, interface="autograd")
def cost_fn(params):
    circuit(params, wires=range(qubits))
    return qml.expval(H)


@qml.qnode(dev, interface="autograd")
def S2_exp_value(params):
    circuit(params, wires=range(qubits))
    return qml.expval(S2)

"""Looping again"""

np.random.seed(0)
theta = np.random.normal(0, np.pi, len(singles) + len(doubles), requires_grad=True)

max_iterations = 100
conv_tol = 1e-06

for n in range(max_iterations):

    theta, prev_energy = opt.step_and_cost(cost_fn, theta)

    excited_energy = cost_fn(theta)
    spin = total_spin(theta)

    conv = np.abs(excited_energy - prev_energy)
    if n % 4 == 0:
        print(f"Step = {n}, Energy = {excited_energy:.8f} Ha, S = {spin:.4f}")

    if conv <= conv_tol:
        break

print("\n" f"Energy of First excited state = {excited_energy:.8f} Ha")
print("\n" f"Optimal value of the circuit parameters = {theta}")

"""Now finding spectral gap"""

spectral_gap = excited_energy - ground_energy
print("Spectral Gap: ", spectral_gap)

